# `8-error`

<br>

You can easily customize *all* error responses generated by Dream, whether from
your application, or at lower levels in the HTTP stack. This is done by passing
the `~error_handler` parameter to `Dream.run`. The easiest way to get an
`error_handler` is to call `Dream.error_template`:

```ocaml
let my_error_template debug_info suggested_response =
  let status = Dream.status suggested_response in
  let code = Dream.status_to_int status
  and reason = Dream.status_to_string status in

  let body =
    <html>
      <body>
        <h1><%i code %> <%s reason %></h1>
%       begin match debug_info with
%       | None -> ()
%       | Some debug_info ->
          <pre><%s debug_info %></pre>
%       end;
      </body>
    </html>
  in

  suggested_response
  |> Dream.with_body body
  |> Lwt.return

let () =
  Dream.run ~error_handler:(Dream.error_template my_error_template)
  @@ Dream.logger
  @@ Dream.not_found
```

<pre><code><b>$ dune exec --root . ./error.exe</b></code></pre>

<br>

We kept the template simple for the sake of the example, but this is where you'd
put in neat graphics to make a beautiful error page!

This app doesn't show debug information by default. However, try adding
`~debug:true` to `Dream.run`, rebuilding the app, and accessing it again.

<br>

Dream will call the error template for every single error response it generates:

1. `4xx` and `5xx` error responses returned by your application.
2. Exceptions raised by your application.
3. Whenever the lower-level HTTP servers want to send a response; for instance,
   a `400 Bad Request` due to malformed headers.

The `suggested_response` argument contains a skeleton response. It is either the
response returned by your application in case (1), an empty `500 Internal
Server Error` if your application raised an exception (2), or a `500 Internal
Server Error` or `400 Bad Request` suggested by the HTTP servers in response to
low-level failures (3).

The easiest thing to do is to decorate `suggested_response` with a fancy
response body, and maybe add some headers. However, you can do anything here,
including build up and return a completely new response.

<br>

`debug_info` is `None` by default. If you passed `~debug:true` to `Dream.run`,
it is `Some` of a string that contains the debug info that we saw in the
previous example, [**`7-debug`**](../7-debug/#files).

<!-- TODO API link. -->
<!-- TODO Images of the generated pages. -->

<br>

If you don't customize the error handler, Dream defaults to sending only empty
responses, so that your application can be fully localization-friendly &mdash;
even at the lowest levels. Dream carefully avoids hardcoding any strings, even
to the point of intercepting strings generated by its HTTP dependencies.

<br>

**Next steps:**

- [**`9-logging`**](../9-logging/#files) shows how to write messages to
  Dream's log.
- [**`a-promise`**](../a-promise/#files) properly introduces Lwt, the promise
  library used by Dream.

<br>

[Up to the tutorial index](../#readme)
