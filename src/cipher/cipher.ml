(* This file is part of Dream, released under the MIT license. See
   LICENSE.md for details, or visit https://github.com/aantron/dream.

   Copyright 2021 Anton Bachin *)



(* TODO Review key derivation. Currently using just some hash to satisfy key
   length requirements. Are there key scope requirements (per-session, etc.)? *)
(* TODO Still need Digestif? *)

(* TODO Choose key_size 32 (256 bits)? *)
(* Block size: 16 (128 bits) *)
(* Tag size: 16 (128 bits) *)
(* Key length recommendation: 256 bits? *)
(* 12-bytes nonce from RFC 5116 par. 2.1. *)

(* TODO Review all | exception cases in all code and avoid them as much sa
   possible. *)
(* TODO Support mixture of encryption and signing. *)
(* TODO Expose this function? *)

module type Cipher =
sig
  val prefix : char
  val name : string

  val encrypt : secret:string -> string -> string
  val decrypt : secret:string -> string -> string option

  val test_encrypt : secret:string -> nonce:string -> string -> string
end

(* type cipher =
  (module Cipher)

type key =
  | Key_and_cipher : ('k * (module Cipher with type key = 'k)) -> key
  [@@ocaml.unboxed]

let cipher_name (module Cipher : Cipher) =
  Cipher.name *)

(* let derive_key (module Cipher : Cipher) secret =
  Key_and_cipher (Cipher.derive_key secret, (module Cipher)) *)

let encrypt (module Cipher : Cipher) secret plaintext =
  Cipher.encrypt ~secret plaintext

let rec decrypt ((module Cipher : Cipher) as cipher) secrets ciphertext =
  match secrets with
  | [] -> None
  | secret::secrets ->
    match Cipher.decrypt ~secret ciphertext with
    | Some _ as plaintext -> plaintext
    | None -> decrypt cipher secrets ciphertext



(* TODO Switch to XChaCha20-Poly1305, but there is no ready implementation in
   OCaml of the whole ciphersuite. Mirage-crypto seems to have the
   components. See https://github.com/mirage/mirage-crypto/issues/111. *)
(* TODO Also consider https://tools.ietf.org/html/rfc8452,
   AEAD_AES_256_GCM_SIV. *)
(* TODO Is it possible to use better nonce generation? Are nonces just taken
   modulo 2^96 internally? *)

(* Key is good for ~2.5 years if every request e.g. generates one new signed
   cookie, and the installation is doing 1000 requests per second. *)
module AEAD_AES_256_GCM =
struct
  (* Enciphered messages are prefixed with a version. There is only one right
     now, version 0, in which the rest of the message consists of:

     - a 96-bit nonce, as recommended in RFC 5116.
     - ciphertext generated by AEAD_AES_256_GCM (RFC 5116).

     The 256-bit key is "derived" from the given secret by hashing it with
     SHA-256.

     See https://tools.ietf.org/html/rfc5116. *)

  (* TODO Move this check to the envelope loop. *)
  let prefix =
    '\x00'

  let name =
    "AEAD_AES_256_GCM, " ^
    "mirage-crypto, key: SHA-256, nonce: 96 bits mirage-crypto-rng"

  (* type key =
    Mirage_crypto.Cipher_block.AES.GCM.key *)

  let derive_key secret =
    secret
    |> Cstruct.of_string
    |> Mirage_crypto.Hash.SHA256.digest
    |> Mirage_crypto.Cipher_block.AES.GCM.of_secret

  (* TODO Memoize keys or otherwise avoid key derivation on every call. *)
  let encrypt_with_nonce secret nonce plaintext =
    let key = derive_key secret in
    let ciphertext =
      Mirage_crypto.Cipher_block.AES.GCM.authenticate_encrypt
        ~key
        ~nonce
        (Cstruct.of_string plaintext)
      |> Cstruct.to_string
    in

    "\x00" ^ (Cstruct.to_string nonce) ^ ciphertext

  let encrypt ~secret plaintext =
    encrypt_with_nonce secret (Random.random_buffer 12) plaintext

  let test_encrypt ~secret ~nonce plaintext =
    encrypt_with_nonce secret (Cstruct.of_string nonce) plaintext

  let decrypt ~secret ciphertext =
    let key = derive_key secret in
    if String.length ciphertext < 14 then
      None
    else
      if ciphertext.[0] != prefix then
        None
      else
        let plaintext =
          Mirage_crypto.Cipher_block.AES.GCM.authenticate_decrypt
            ~key
            ~nonce:(Cstruct.of_string ~off:1 ~len:12 ciphertext)
            (Cstruct.of_string ciphertext ~off:13)
        in
        match plaintext with
        | None -> None
        | Some plaintext -> Some (Cstruct.to_string plaintext)
end



(* let cipher =
  (module AEAD_AES_256_GCM : Cipher)

let decryption_ciphers = [
  cipher;
] *)
