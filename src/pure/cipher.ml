(* This file is part of Dream, released under the MIT license. See
   LICENSE.md for details, or visit https://github.com/aantron/dream.

   Copyright 2021 Anton Bachin *)



(* TODO Review key derivation. Currently using just some hash to satisfy key
   length requirements. Are there key scope requirements (per-session, etc.)? *)
(* TODO Still need Digestif? *)

(* TODO Choose key_size 32 (256 bits)? *)
(* Block size: 16 (128 bits) *)
(* Tag size: 16 (128 bits) *)
(* Key length recommendation: 256 bits? *)
(* 12-bytes nonce from RFC 5116 par. 2.1. *)

(* TODO Review all | exception cases in all code and avoid them as much sa
   possible. *)
(* TODO Support mixture of encryption and signing. *)
(* TODO Expose this function? *)

module type Cipher =
sig
  val prefix : char
  val name : string

  type key

  val derive_key : string -> key
  val encrypt : key -> string -> string
  val decrypt : key -> string -> string option

  val test_encrypt : key -> nonce:string -> string -> string
end

type cipher =
  (module Cipher)

type key =
  | Key_and_cipher : ('k * (module Cipher with type key = 'k)) -> key
  [@@ocaml.unboxed]

let cipher_name (module Cipher : Cipher) =
  Cipher.name

let derive_key (module Cipher : Cipher) secret =
  Key_and_cipher (Cipher.derive_key secret, (module Cipher))

let encrypt (Key_and_cipher (key, (module Cipher))) plaintext =
  Cipher.encrypt key plaintext

let rec decrypt keys ciphertext =
  match keys with
  | [] -> None
  | Key_and_cipher (key, (module Cipher)) :: keys ->
    match Cipher.decrypt key ciphertext with
    | Some _ as plaintext -> plaintext
    | None -> decrypt keys ciphertext



module AEAD_AES_256_GCM =
struct
  (* Enciphered messages are prefixed with a version. There is only one right
     now, version 0, in which the rest of the message consists of:

     - a 96-bit nonce, as recommended in RFC 5116.
     - ciphertext generated by AEAD_AES_256_GCM (RFC 5116).

     The 256-bit key is "derived" from the given secret by hashing it with
     SHA-256.

     See https://tools.ietf.org/html/rfc5116. *)

  (* TODO Move this check to the envelope loop. *)
  let prefix =
    '\x00'

  let name =
    "AEAD_AES_256_GCM"

  type key =
    Mirage_crypto.Cipher_block.AES.GCM.key

  let derive_key secret =
    secret
    |> Cstruct.of_string
    |> Mirage_crypto.Hash.SHA256.digest
    |> Mirage_crypto.Cipher_block.AES.GCM.of_secret

  let encrypt_with_nonce key nonce plaintext =
    let ciphertext =
      Mirage_crypto.Cipher_block.AES.GCM.authenticate_encrypt
        ~key
        ~nonce
        (Cstruct.of_string plaintext)
      |> Cstruct.to_string
    in

    "\x00" ^ (Cstruct.to_string nonce) ^ ciphertext

  let encrypt key plaintext =
    encrypt_with_nonce key (Random.random_buffer 12) plaintext

  let test_encrypt key ~nonce plaintext =
    encrypt_with_nonce key (Cstruct.of_string nonce) plaintext

  let decrypt key ciphertext =
    if String.length ciphertext < 14 then
      None
    else
      if ciphertext.[0] != prefix then
        None
      else
        let plaintext =
          Mirage_crypto.Cipher_block.AES.GCM.authenticate_decrypt
            ~key
            ~nonce:(Cstruct.of_string ~off:1 ~len:12 ciphertext)
            (Cstruct.of_string ciphertext ~off:13)
        in
        match plaintext with
        | None -> None
        | Some plaintext -> Some (Cstruct.to_string plaintext)
end



let cipher =
  (module AEAD_AES_256_GCM : Cipher)

let decryption_ciphers = [
  cipher;
]
